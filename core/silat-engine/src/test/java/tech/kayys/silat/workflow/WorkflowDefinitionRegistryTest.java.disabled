package tech.kayys.silat.workflow;

import io.quarkus.test.junit.QuarkusTest;
import io.smallrye.mutiny.helpers.test.UniAssertSubscriber;
import jakarta.inject.Inject;
import org.junit.jupiter.api.Test;

import tech.kayys.silat.model.TenantId;
import tech.kayys.silat.model.WorkflowDefinition;
import tech.kayys.silat.model.WorkflowDefinitionId;

import static org.junit.jupiter.api.Assertions.*;

@QuarkusTest
class WorkflowDefinitionRegistryTest {

    @Inject
    WorkflowDefinitionRegistry registry;

    @Test
    void getDefinition_whenExists_returnsDefinition() {
        // Note: This test will depend on the actual repository implementation
        // For now, we'll test the basic functionality assuming a workflow exists

        WorkflowDefinitionId id = WorkflowDefinitionId.of("nonexistent-wf");
        TenantId tenantId = TenantId.of("tenant1");

        // This should throw NoSuchElementException since the workflow doesn't exist
        Exception exception = assertThrows(RuntimeException.class, () -> {
            registry.getDefinition(id, tenantId)
                    .subscribe().withSubscriber(UniAssertSubscriber.create()).awaitItem().getItem();
        });

        assertTrue(exception.getMessage().contains("Workflow definition not found"));
    }

    @Test
    void register_whenValidDefinition_registersSuccessfully() {
        // Arrange
        WorkflowDefinition definition = WorkflowDefinition.builder()
                .id(WorkflowDefinitionId.of("test-wf-" + System.currentTimeMillis()))
                .name("test-workflow")
                .tenantId(TenantId.of("tenant1"))
                .build();
        TenantId tenantId = TenantId.of("tenant1");

        // Note: This test depends on the repository implementation
        // For now, we'll just verify that calling register doesn't throw an exception
        // due to validation (the actual persistence depends on the repository)

        // The registry.register method will call repository.save which may fail
        // depending on the actual repository implementation
        assertDoesNotThrow(() -> {
            registry.register(definition, tenantId)
                    .subscribe().withSubscriber(UniAssertSubscriber.create()).awaitItem();
        });
    }

    @Test
    void register_whenInvalidDefinition_throwsException() {
        // Arrange
        WorkflowDefinition invalidDefinition = WorkflowDefinition.builder()
                .id(WorkflowDefinitionId.of("invalid-wf"))
                .name("") // Invalid name
                .tenantId(TenantId.of("tenant1"))
                .build();
        TenantId tenantId = TenantId.of("tenant1");

        // Act & Assert
        Exception exception = assertThrows(RuntimeException.class, () -> {
            registry.register(invalidDefinition, tenantId)
                    .subscribe().withSubscriber(UniAssertSubscriber.create()).awaitItem().getItem();
        });

        assertTrue(exception.getMessage().contains("Invalid workflow definition"));
    }

    @Test
    void listDefinitions_callsRepository() {
        // Arrange
        TenantId tenantId = TenantId.of("tenant1");

        // Act & Assert - Just verify that the method can be called without throwing
        assertDoesNotThrow(() -> {
            registry.listDefinitions(tenantId, true)
                    .subscribe().withSubscriber(UniAssertSubscriber.create()).awaitItem();
        });
    }

    @Test
    void invalidateCache_removesFromCache() {
        // Arrange
        WorkflowDefinitionId id = WorkflowDefinitionId.of("test-wf");
        TenantId tenantId = TenantId.of("tenant1");

        // Act - This should not throw any exceptions
        assertDoesNotThrow(() -> {
            registry.invalidateCache(id, tenantId);
        });
    }

    @Test
    void clearCache_clearsEntireCache() {
        // Act - This should not throw any exceptions
        assertDoesNotThrow(() -> {
            registry.clearCache();
        });
    }
}